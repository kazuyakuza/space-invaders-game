# TODO: Implement Headless Unit Testing

## IMPORTANT NOTE

The test to be implemented will probably fail.
Fix the game error IS NOT PART of this task.
The error right now remains unfix to be able to implement this test and verify that it fails for th current error.

## Objective

Implement unit tests for the level resolution logic without requiring a browser environment.

## Test Strategy

Use **Vitest** (recommended as we are using Vite) to test the core game logic in a Node.js environment with mocked DOM APIs.

### Test Target

The [`resolveLevelConfig`](src/ts/Game.ts:135) method in [`src/ts/Game.ts`](src/ts/Game.ts).

### Setup Requirements

1. **Framework**: Install Vitest (`npm install -D vitest`).
2. **DOM Mocking**: Use `jsdom` or `happy-dom` to provide a mock `document.getElementById` and `HTMLCanvasElement`.
3. **Canvas Mocking**: Use `vitest-canvas-mock` or a simple manual stub for the 2D context.

### Test Cases

- **Case 1: Full Definition**: Verify that Level 1 loads all properties from its static definition.
- **Case 2: Sparse Inheritance**: Verify that Level 2 (missing rows/cols) correctly inherits those values from Level 1.
- **Case 3: Incremental Accumulation**: Verify that properties prefixed with `+` are correctly added to the base values.
- **Case 4: Infinity Fallback**: Verify that requesting a level beyond the defined range returns the correct repeated configuration.

## Implementation Plan

- [ ] Create `src/ts/__tests__/Game.test.ts`.
- [ ] Mock the `levels.json` import using `vi.mock`.
- [ ] Initialize a `Game` instance and call the resolution logic.
- [ ] Assert the final configuration objects.

## Benefits

- **Speed**: Runs in milliseconds.
- **CI/CD**: Can be easily integrated into automated pipelines.
- **Isolation**: Tests logic without visual or rendering side effects.
